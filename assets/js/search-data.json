{
  
    
        "post0": {
            "title": "Text classification without annotated data in the BERT era",
            "content": "Natural language processing is an enthrallingly exciting field right now. In recent years, the community has begun to figure out some pretty effective methods of learning from the enormous amounts of unlabeled data on the internet. The success of transfer learning from unsupervised models has allowed us to surpass virtually all existing benchmarks on downstream supervised learning tasks. As we continue to develop new model architectures and unsupervised learning objectives, &quot;state of the art&quot; continues to be a rapidly moving target for many tasks where large amounts of labeled data is available. . In many real-world settings, however, annotated data is either scarse or unavailable entirely. It seems almost tragic that we could have such success in unsupervised learning as a pre-training step but having focused so little on alleviating our reliance on labaled data in downstream applications like sequence classification. Recent models like BERT, XLNet, and T5 have been shown to encode a tremendous amount of information in their weights ‚Äì it seems like we should be able to figure out a way to use that data in traditionally supervised tasks but without such a heavy reliance on task-specific annotated data. . Of course, some research has in fact been done in this area. In this post, I will give an overview of a few techniques, both from published research and my own experiments, for using state-of-the-art NLP models for sequence classification in the absense of large annotated datasets. Specifically, I will cover the following low-resource settings, with a focus on the first: . I have no training data (extreme zero-shot learning) | I have sufficient data for some labels, but not for others (traditional zero-shot learning) | I have a little bit of annotated data (few-shot learning) | I have no annotated data, but lots of unlabeled data (unsupervised classification) | At the end of the post, I also link a few fantastic resources out there for NLP in low-resource languages. While I focus specifically on sequence-level classification, my hope is that some of these methods will be applicable to or inspire ideas for other kinds of tasks as well. . Setting: I have no training data . As a starting poing, we will consider the most extreme setting where we have no access training data of any kind. To make this problem tractable, we do assume that we have some kind of textual descriptor of the classes ‚Äì¬†typically just the names of the classes. The basic idea at play is to use a pretrained model to get a latent representation for the data and labels, allowing us to infer something about the relationship between them. . Background: Natural Language Inference (NLI) . Several of the methods described below use Natural Language Inference as a pre-training step, so here is a quick review. NLI considers two sentences: a &quot;premise&quot; and a &quot;hypothesis&quot;. The task is to determine whether the hypothesis is true (entailment) or false (contradiction) given the premise. . . When using transformer architectures like BERT, NLI datasets are typically modeled via sequence-pair classification. That is, we feed both the premise and the hypothesis through the model together as distinct segments and learn a classification head predicting one of [contradiction, neutral, entailment]. . A latent embedding approach . A common approach to zero shot learning in the computer vision setting is to use an existing featurizer to embed an image and any possible class names into their corresponding latent representations. They can then take some training set and use only a subset of the available labels to learn a linear projection to align the image and label embeddings. At test time, this framework allows one to embed any label (seen or unseen) and any image into the same latent space and measure their distance. . In the text domain, we have the advantage that we can use a single model to embed both the data and the class names into the same space, eliminating the need for the data-hungry alignment step. This is not a new technique ‚Äì researchers and practitioners have used pooled word vectors in similar ways for some time. But recently we have seen a dramatic increase in the quality of sentence embedding models. We therefore decided to run some experiments with Sentence-BERT, a recent technique which fine-tunes the pooled sequence representations for increased semantic richness, as a method for obtaining sequence and label embeddings. . To formalize this, suppose we have a sequence embedding model $ Phi$ and set of possible class names $C$. We classify a given sequence $x$ according to, . $$ hat{c} = arg max_{c in C} cos( Phi(x), Phi(c)) $$where $ cos$ is the cosine similarity. Here&#39;s an example code snippet showing how this can be done using Sentence-BERT as our embedding model $ Phi$: . # load the sentence-bert model from the HuggingFace model hub from transformers import AutoTokenizer, AutoModel from torch.nn import functional as F tokenizer = AutoTokenizer.from_pretrained(&#39;deepset/sentence_bert&#39;) model = AutoModel.from_pretrained(&#39;deepset/sentence_bert&#39;) sentence = &#39;Who are you voting for in 2020?&#39; labels = [&#39;business&#39;, &#39;art &amp; culture&#39;, &#39;politics&#39;] # run inputs through model and mean-pool over the sequence # dimension to get sequence-level representations inputs = tokenizer.batch_encode_plus([sentence] + labels, return_tensors=&#39;pt&#39;, pad_to_max_length=True) input_ids = inputs[&#39;input_ids&#39;] attention_mask = inputs[&#39;attention_mask&#39;] output = model(input_ids, attention_mask=attention_mask)[0] sentence_rep = output[:1].mean(dim=1) label_reps = output[1:].mean(dim=1) # now find the labels with the highest cosine similarities to # the sentence similarities = F.cosine_similarity(sentence_rep, label_reps) closest = similarities.argsort(descending=True) for ind in closest: print(f&#39;label: {labels[ind]} t similarity: {similarities[ind]}&#39;) . label: politics similarity: 0.21561521291732788 label: business similarity: 0.004524140153080225 label: art &amp; culture similarity: -0.027396833524107933 . Note: This code snippet uses deepset/sentence_bert which is the smallest version of the S-BERT model. Our experiments use larger models which are currently available only in the sentence-transformers GitHub repository, which we hope to make available in the Hugging Face model hub soon. . . One problem to this method is that Sentence-BERT is designed to learn effective sentence-level, not single- or multi-word representations like our class names. It is therefore reasonable to suppose that our label embeddings may not be as semantically salient as popular word-level embedding methods (i.e. word2vec). This is seen in the t-SNE visualization above where the data cluster together by class reasonably well, but the labels are poorly aligned. If we were to use word vectors as our label representations, however, we would need annotated data to learn an alignment between the S-BERT sequence representations and the word2vec label representations. . We addressed this issue with the following procedure: . Take the top $K$ most frequent words $V$ in the vocabulary of a word2vec model | Obtain embeddings for each word using word2vec, $ Phi_{ text{word}}(V)$ | Obtain embeddings for each word using S-BERT, $ Phi_{ text{sent}}(V)$ | Learn a least-squares linear projection $W$ with L2 regularization from $ Phi_{ text{sent}}(V)$ to $ Phi_{ text{word}}(V)$ | Now we use $W$ in our classification as an additional transformation to our latent space for both sequence and label embeddings: . $$ hat{c} = arg max_{c in C} cos( Phi_{ text{sent}}(x)W, Phi_{ text{sent}}(c)W) $$This procedure can be thought of as a kind of dimensionality reduction. As seen in the t-SNE visual below, this projection makes the label embeddings much better aligned with their corresponding data while maintining the superior performance of S-BERT compared to pooled word vectors. Importantly, this procedure does not require any additional data beyond a word2vec mapping sorted by word frequency. . . On Yahoo Answers, we find an F1 of $46.9$ and $31.2$ with and without this projection step, respectively. . Using NLI models as effective, ready-made zero-shot classifiers . Recently, Yin et al. (2019) proposed a method which uses a pre-trained MNLI sequence-pair classifier as an out-of-the-box zero-shot text classifier that actually works pretty well. . The idea is to take the sequence we&#39;re interested in labeling as the &quot;premise&quot; and to turn each candidate label into a &quot;hypothesis.&quot; If the NLI model predicts that the premise &quot;entails&quot; the hypothesis, we take the label to be true. Unlike the previous approach which utilizes independent embeddings for the data and labels and requires us to determine their relationship, this method gives us a ready-made compatibility function that works reasonably well without any task-specific training. See the code snippet below which demonstrates how easily this can be done with ü§ó Transformers. . # load model pretrained on MNLI from transformers import BartForSequenceClassification, BartTokenizer tokenizer = BartTokenizer.from_pretrained(&#39;bart-large-mnli&#39;) model = BartForSequenceClassification.from_pretrained(&#39;bart-large-mnli&#39;) # pose sequence as a NLI premise and label (politics) as a hypothesis premise = &#39;Who are you voting for in 2020?&#39; hypothesis = &#39;This text is about politics.&#39; # run through model pre-trained on MNLI input_ids = tokenizer.encode(premise, hypothesis, return_tensors=&#39;pt&#39;) logits = model(input_ids)[0] # we throw away &quot;neutral&quot; (dim 1) and take the probability of # &quot;entailment&quot; (2) as the probability of the label being true entail_contradiction_logits = logits[:,[0,2]] probs = entail_contradiction_logits.softmax(dim=1) true_prob = probs[:,1].item() * 100 print(f&#39;Probability that the label is true: {true_prob:0.2f}%&#39;) . Probability that the label is true: 99.04% . In the paper, the authors report a label-weighted F1 of $37.9$ on Yahoo Answers topic classification using the smallest version of BERT fine-tuned only on the Multi-genre NLI (MNLI) corpus. By simply using the larger and more recent Bart model pre-trained on MNLI, we were able to bring this number up to $53.7$. For context, Yahoo Answers has 10 classes and supervised models get an accuracy of just over $70 %$. . Of course, this number can be improved when some data is available for training. In addition to the extreme fully unsupervised setting, the authors consider a setup which corresponds to the traditional generalized zero-shot learning setting where only a subset of the dataset&#39;s labels are available during training. The model is then evaluated on all labels together, both seen and unseen, at test time. . See our live demo here to try it out for yourself! Enter a sequence you want to classify and any labels of interest and watch Bart do its magic in real time. . . Setting: I have sufficient data for some labels, but not for others . short description . methods . Setting: I have a little bit of annotated data . short description . methods . additional reading . Setting: I have no annotated data, but lots of unlabeled data . description here . methods . additional reading . Setting: Low-Resource Languages . Low-resource and cross-lingual learning is a huge research area in NLP right now and much has been written about it, so I&#39;ll just link a few great resources: . Graham Neubig&#39;s recently released Low Resource NLP Bootcamp is a GitHub repo containing 8 lectures (plus exercises) focused on NLP in data-scarse languages. . | Sebastian Ruder&#39;s blog post, &quot;A survey of cross-lingual word embedding models&quot; . | .",
            "url": "https://joeddav.github.io/blog/2020/05/28/ZSL.html",
            "relUrl": "/2020/05/28/ZSL.html",
            "date": " ‚Ä¢ May 28, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "REALM: Knowledge and Transformers",
            "content": "Summary for the Hugging Face awesome-papers reading group, March 3, 2020. Paper: https://arxiv.org/abs/2002.08909. . Background: Language Models as Knowledge Bases . Due in large part to the massive size and scope of the text corpora on which they are trained, huge language representation learners like BERT have been shown to encode a surprising amount of world knowledge in their weights. A recent EMNLP paper posed the question of whether models like BERT can be thought of as having some form of latent knowledge base in their parameters. Models like BERT, and in particular T5, have been shown to do surprisingly well on open-domain question answering, a deliberately information-intensive task, despite having no access to external databases (incidentally, REALM shows how well we can do when such a model is given that access). All of this is to suggest the possibility that, given enough parameters and training data, models might be able to make external knowledge augmentation superflous, instead inferring relevant knowledge from text corpora and encoding it in its parameters. . Background: Instance-based Learning and Retrieve-and-edit Models . Instance- or memory-based learning is a family of ML algorithms which compare a data point with instances already seen in training (or existing in some reference set), rather than relying entirely on learned model parameters for generalization. An example of this class of algorithm is KNN, which looks up the most similar points in a training set to generalize to a new instance. Retrieve-and-edit can be thought of as a type of instance-based learning with two components: a retriever which chooses similar training examples to a given data point, and an editor which then modifies the retrieved examples to form an appropriate prediction. . Recently, KNN Language Models was proposed as an ICLR 2020 paper. This method looks up the nearest neighbors in LM-embedding space to generate target word predictions. The method does quite well in terms of perplexity, but the authors don‚Äôt evaluate on downstream task performance, and it‚Äôs questionable how amenable the method is to downstream fine-tuning at all. Regardless, it‚Äôs a great example of using instance-based learning to improve model performance. . Unlike KNN-LM, REALM incorporates retrieved instances by appending them to the model context, but it is not the first to propose such a method. Its direct precursor (published by one of REALM‚Äôs first authors), Latent Retrieval for Weakly Supervised Open Domain Question Answering, introduces a pre-training task for the corpus retriever which ‚Äúmakes it possible‚Äù to train end-to-end on Wikipedia. Much of the work presented here as novel actually builds upon work done in this prior publication. The specific contributions presented in the REALM paper largely involve pre-training tasks and computational tricks, ultimately yielding impressive empirical results on OpenQA. Other methods, such as Facebook‚Äôs DrQA, employ methods for retrieving knowledge from Wikipedia text as well. . REALM: Retrieval-Augmented Langauge Models . The authors propose a method for training a masked language model (MLM) by sparsely ‚Äúattending‚Äù over all of Wikipedia in an end-to-end fashion. . . At a high level, the method goes like this: find the most similar text passages in BERT space, add those passages to the input as additional context, and then make a prediction. . Here‚Äôs the more formal, probabilistic explanation of their training objective: Suppose we have a corrupted sentence $x$ and hidden tokens $y$, as well as a textual knowledge corpus $ mathcal{Z}$ (i.e., Wikipedia articles). The objective involves marginalizing over the entire Wikipedia corpus: . begin{equation} p(y|x) = sum_{z in mathcal{Z}} p(y|x,z) p(z|x) end{equation} . Of course, summing over every document in Wikipedia is computationally impractical. In some cases we approximate things like this with Monte Carlo: begin{equation} p(y|x) approx frac{1}{K} sum_{z sim p(z|x)}^K p(y|x,z) end{equation} In other words, if we can sample $K$ documents from the conditional distribution $p(z|x)$ and sum over the resulting target likelihoods, we get an unbiased estimator of the objective. . In practice, the authors sample from Wikipedia by simply taking the top $K$ most similar documents to $x$. They did this because selecting the top $K$ allows them to use Maximum Inner Product Search (MIPS) for huge computational benefits, but at the cost of a biased approximation of the objective. . . The authors evaluate their model on the downstream task of open-domain question answering, comfortably outperforming all other evaluated systems. It should also be noted that most of the included benchmark methods (excluding T5) also use Wikipedia in some way for external information at test time. . . My 2¬¢ . I found this paper interesting because of its commentary on knowledge representation and instance-based language modeling. Do language models have latent knowledge bases? To what degree is that knowledge accessible? This paper makes the argument for ‚Äúexplicitly‚Äù modeling the relevant knowledge needed to perform a given task, rather than relying on inferred knowledge. However, the impressive performance on OpenQA benchmarks notwithstanding, they do nothing to substantiate their claims about improved interpretability and modularity of model predictions. For all we know, retrieval from Wikipedia could have increased the knowledge encoded in the model parameters, rather than decreased it. . It would also have been interesting to see more analysis on what exactly the model gets out of retrieved examples. Given that Wikipedia is a natural text corpus, is it possible that the model is attending to linguistic cues in retrieved examples in addition to factual information? The paper focused more on the computational aspect of things, which to be fair is arguably where their greatest contribution was, but I wish they had done some more analysis. . Discussion Questions . In the introduction, the authors state the following: ‚ÄúIn contrast to models that store knowledge in their parameters, this approach explicitly exposes the role of world knowledge by asking the model to decide what knowledge to retrieve and use during inference.‚Äù In what way is is this type of knowledge-augmented model valuable compared to standard models which rely on the ‚Äúlatent knowledge‚Äù in their parameters? Will the future of NLP involve explicitly incorporating external knowledge, or will such methods become obsolete with bigger and better models? | Should Wikipedia be the go-to general ‚Äúknowledge base‚Äù? Should we focus more on structured knowledge (such as WikiData, which is built from Wikipedia) or large text corpora? | The REALM objective involves marginalizing over the document corpus. The authors approximate this by summing over the predictions corresponding to the top-k highest scoring documents. Presumably, they take this approach (rather than coming up with a stochastic sampling method) to get the computational advantages of asynchronous MIPS. Is this biased estimator of the objective problematic or not a big deal? Why? | Is there a future for instance-based models like REALM in transformers? | In the discussion, the authors mention that there are several different lenses through which you can view their method: a different take on knowledge representation and augmentation; a transformer with much larger, sparsely-attended contexts; a memory-based or retrieve-and-edit model with learned retrieval. Do any of these perspectives particularly resonate? Are there others that you prefer? | Summary of HF Internal Discussion . When knowledge needs to be updated, models like T5 which encode knowledge in their weights must be retrained to reflect the new information. If the model relies on the knowledge base, theoretically all you have to do is update the knowledge base. That‚Äôs a major advantage for real-life deployed QA systems, for example. | Bootstrapping the retrieval model is a tough thing to do and the Inverse Cloze Task is a smart way to go about it. | Impossible to know whether the biased objective (Q3 above) has a negative impact on results without more analysis or experimentation, but it would have been nice if the authors discussed it more in the paper. | It would nice to see evaluation on tasks other than just OpenQA. | .",
            "url": "https://joeddav.github.io/blog/2020/03/03/REALM.html",
            "relUrl": "/2020/03/03/REALM.html",
            "date": " ‚Ä¢ Mar 3, 2020"
        }
        
    
  

  
  

  

  
  

  
  

  

  
  

  

  
      ,"page7": {
          "title": "",
          "content": "Warning . Do not manually save images into this folder. This is used by GitHub Actions to automatically copy images. Any images you save into this folder could be deleted at build time. .",
          "url": "https://joeddav.github.io/blog/images/copied_from_nb/",
          "relUrl": "/images/copied_from_nb/",
          "date": ""
      }
      
  

  
  

}
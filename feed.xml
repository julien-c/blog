<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://joeddav.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://joeddav.github.io/blog/" rel="alternate" type="text/html" /><updated>2020-05-26T13:46:36-05:00</updated><id>https://joeddav.github.io/blog/feed.xml</id><title type="html">Joe Davison</title><subtitle>Just a simple fastpages site for publishing things here and there</subtitle><entry><title type="html">An Overview of Zero Shot Learning in NLP</title><link href="https://joeddav.github.io/blog/2020/05/28/ZSL.html" rel="alternate" type="text/html" title="An Overview of Zero Shot Learning in NLP" /><published>2020-05-28T00:00:00-05:00</published><updated>2020-05-28T00:00:00-05:00</updated><id>https://joeddav.github.io/blog/2020/05/28/ZSL</id><content type="html" xml:base="https://joeddav.github.io/blog/2020/05/28/ZSL.html">&lt;!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-05-28-ZSL.ipynb
--&gt;

&lt;div class=&quot;container&quot; id=&quot;notebook-container&quot;&gt;
        
    
    
&lt;div class=&quot;cell border-box-sizing code_cell rendered&quot;&gt;

&lt;/div&gt;
    

&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;h3 id=&quot;A-Ready-made-Zero-Shot-Text-Classifier-with-&amp;#129303;-Transformers&quot;&gt;A Ready-made Zero-Shot Text Classifier with &amp;#129303; Transformers&lt;a class=&quot;anchor-link&quot; href=&quot;#A-Ready-made-Zero-Shot-Text-Classifier-with-&amp;#129303;-Transformers&quot;&gt; &lt;/a&gt;&lt;/h3&gt;&lt;p&gt;At EMNLP last year, &lt;a href=&quot;https://dx.doi.org/10.18653/v1/d19-1404&quot;&gt;Yin et al.&lt;/a&gt; proposed a method which uses a pre-trained MNLI sequence-pair classifier as an out-of-the-box text/label compatibility function.&lt;/p&gt;
&lt;p&gt;The idea is to take the sequence as the &quot;premise&quot; and turn each possible label of interest into a &quot;hypothesis.&quot;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
    
    
&lt;div class=&quot;cell border-box-sizing code_cell rendered&quot;&gt;
&lt;details class=&quot;description&quot; open=&quot;&quot;&gt;
      &lt;summary class=&quot;btn btn-sm&quot; data-open=&quot;Hide Code&quot; data-close=&quot;Show Code&quot;&gt;&lt;/summary&gt;
        &lt;p&gt;&lt;div class=&quot;input&quot;&gt;

&lt;div class=&quot;inner_cell&quot;&gt;
    &lt;div class=&quot;input_area&quot;&gt;
&lt;div class=&quot; highlight hl-ipython3&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;#collapse-show&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# load model pretrained on MNLI&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;transformers&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AutoModelForSequenceClassification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AutoTokenizer&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tokenizer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AutoTokenizer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_pretrained&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;bart-large-mnli&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AutoModelForSequenceClassification&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from_pretrained&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;bart-large-mnli&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# pose sequence as a NLI premise and label (politics) as a hypothesis&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;premise&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Who are you voting for in 2020?&amp;quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hypothesis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;This text is about politics.&amp;#39;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# run through model pre-trained on MNLI&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;input_ids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokenizer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;premise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hypothesis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return_tensors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;pt&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;logits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_ids&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# we throw away &amp;quot;neutral&amp;quot; (dim 1) and take the probability of&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# &amp;quot;entailment&amp;quot; (2) as the probability of the label being true &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;entail_contradiction_logits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:,[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;probs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entail_contradiction_logits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;softmax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;true_prob&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;probs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;Probability that the label is true: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;true_prob&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;0.2f&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;%&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
    &lt;/details&gt;
&lt;/div&gt;
    

&lt;/div&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">REALM: Knowledge and Transformers</title><link href="https://joeddav.github.io/blog/2020/03/03/REALM.html" rel="alternate" type="text/html" title="REALM: Knowledge and Transformers" /><published>2020-03-03T00:00:00-06:00</published><updated>2020-03-03T00:00:00-06:00</updated><id>https://joeddav.github.io/blog/2020/03/03/REALM</id><content type="html" xml:base="https://joeddav.github.io/blog/2020/03/03/REALM.html">&lt;p&gt;&lt;em&gt;Summary for the Hugging Face &lt;a href=&quot;https://github.com/huggingface/awesome-papers&quot;&gt;awesome-papers&lt;/a&gt; reading group, March 3, 2020. Paper: &lt;a href=&quot;https://arxiv.org/abs/2002.08909&quot;&gt;https://arxiv.org/abs/2002.08909&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;background-language-models-as-knowledge-bases&quot;&gt;Background: Language Models as Knowledge Bases&lt;/h3&gt;
&lt;p&gt;Due in large part to the massive size and scope of the text corpora on which they are trained, huge language representation learners like BERT have been shown to encode a surprising amount of world knowledge in their weights. &lt;a href=&quot;https://arxiv.org/abs/1909.01066&quot;&gt;A recent EMNLP paper&lt;/a&gt; posed the question of whether models like BERT can be thought of as having some form of latent knowledge base in their parameters. Models like BERT, and in particular &lt;a href=&quot;https://arxiv.org/abs/1910.10683&quot;&gt;T5&lt;/a&gt;, have been shown to do surprisingly well on open-domain question answering, a deliberately information-intensive task, despite having no access to external databases (incidentally, REALM shows how well we can do when such a model is given that access). All of this is to suggest the possibility that, given enough parameters and training data, models might be able to make external knowledge augmentation superflous, instead inferring relevant knowledge from text corpora and encoding it in its parameters.&lt;/p&gt;

&lt;h3 id=&quot;background-instance-based-learning-and-retrieve-and-edit-models&quot;&gt;Background: Instance-based Learning and Retrieve-and-edit Models&lt;/h3&gt;
&lt;p&gt;Instance- or memory-based learning is a family of ML algorithms which compare a data point with instances already seen in training (or existing in some reference set), rather than relying entirely on learned model parameters for generalization. An example of this class of algorithm is KNN, which looks up the most similar points in a training set to generalize to a new instance. Retrieve-and-edit can be thought of as a type of instance-based learning with two components: a &lt;em&gt;retriever&lt;/em&gt; which chooses similar training examples to a given data point, and an &lt;em&gt;editor&lt;/em&gt; which then modifies the retrieved examples to form an appropriate prediction.&lt;/p&gt;

&lt;p&gt;Recently, &lt;a href=&quot;https://arxiv.org/abs/1911.00172&quot; title=&quot;Generalization through Memorization: Nearest Neighbor Language Models&quot;&gt;KNN Language Models&lt;/a&gt; was proposed as an ICLR 2020 paper. This method looks up the nearest neighbors in LM-embedding space to generate target word predictions. The method does quite well in terms of perplexity, but the authors don’t evaluate on downstream task performance, and it’s questionable how amenable the method is to downstream fine-tuning at all. Regardless, it’s a great example of using instance-based learning to improve model performance.&lt;/p&gt;

&lt;p&gt;Unlike KNN-LM, REALM incorporates retrieved instances by appending them to the model context, but it is not the first to propose such a method. Its direct precursor (published by one of REALM’s first authors), &lt;a href=&quot;https://arxiv.org/abs/1906.00300&quot;&gt;Latent Retrieval for Weakly Supervised Open Domain Question Answering&lt;/a&gt;, introduces a pre-training task for the corpus retriever which “makes it possible” to train end-to-end on Wikipedia. Much of the work presented here as novel actually builds upon work done in this prior publication. The specific contributions presented in the REALM paper largely involve pre-training tasks and computational tricks, ultimately yielding impressive empirical results on OpenQA. Other methods, such as Facebook’s &lt;a href=&quot;https://arxiv.org/abs/1704.00051&quot;&gt;DrQA&lt;/a&gt;, employ methods for retrieving knowledge from Wikipedia text as well.&lt;/p&gt;

&lt;h3 id=&quot;realm-retrieval-augmented-langauge-models&quot;&gt;REALM: Retrieval-Augmented Langauge Models&lt;/h3&gt;
&lt;p&gt;The authors propose a method for training a masked language model (MLM) by sparsely “attending” over all of Wikipedia in an end-to-end fashion.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/realm_fig.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At a high level, the method goes like this: find the most similar text passages in BERT space, add those passages to the input as additional context, and then make a prediction.&lt;/p&gt;

&lt;p&gt;Here’s the more formal, probabilistic explanation of their training objective: Suppose we have a corrupted sentence $x$ and hidden tokens $y$, as well as a textual knowledge corpus $\mathcal{Z}$ (i.e., Wikipedia articles). The objective involves marginalizing over the entire Wikipedia corpus:&lt;/p&gt;

&lt;p&gt;\begin{equation}
p(y|x) = \sum_{z\in\mathcal{Z}} p(y|x,z) p(z|x)
\end{equation}&lt;/p&gt;

&lt;p&gt;Of course, summing over every document in Wikipedia is computationally impractical. In some cases we approximate things like this with Monte Carlo:
\begin{equation}
p(y|x) \approx \frac{1}{K} \sum_{z\sim p(z|x)}^K p(y|x,z)
\end{equation}
In other words, if we can sample $K$ documents from the conditional distribution $p(z|x)$ and sum over the resulting target likelihoods, we get an unbiased estimator of the objective.&lt;/p&gt;

&lt;p&gt;In practice, the authors sample from Wikipedia by simply taking the top $K$ most similar documents to $x$. They did this because selecting the top $K$ allows them to use Maximum Inner Product Search (MIPS) for huge computational benefits, but at the cost of a biased approximation of the objective.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/realm_retrieval_examples.png&quot; alt=&quot;&quot; title=&quot;Example of text retrieval for a given text input&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The authors evaluate their model on the downstream task of open-domain question answering, comfortably outperforming all other evaluated systems. It should also be noted that most of the included benchmark methods (excluding T5) also use Wikipedia in some way for external information at test time.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/realm_results.png&quot; alt=&quot;&quot; title=&quot;REALM OpenQA Results&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;my-2&quot;&gt;My 2¢&lt;/h3&gt;

&lt;p&gt;I found this paper interesting because of its commentary on knowledge representation and instance-based language modeling. Do language models have latent knowledge bases? To what degree is that knowledge accessible? This paper makes the argument for “explicitly” modeling the relevant knowledge needed to perform a given task, rather than relying on inferred knowledge. However, the impressive performance on OpenQA benchmarks notwithstanding, they do nothing to substantiate their claims about improved interpretability and modularity of model predictions. For all we know, retrieval from Wikipedia could have &lt;em&gt;increased&lt;/em&gt; the knowledge encoded in the model parameters, rather than decreased it.&lt;/p&gt;

&lt;p&gt;It would also have been interesting to see more analysis on &lt;em&gt;what exactly&lt;/em&gt; the model gets out of retrieved examples. Given that Wikipedia is a natural text corpus, is it possible that the model is attending to linguistic cues in retrieved examples in addition to factual information? The paper focused more on the computational aspect of things, which to be fair is arguably where their greatest contribution was, but I wish they had done some more analysis.&lt;/p&gt;

&lt;h3 id=&quot;discussion-questions&quot;&gt;Discussion Questions&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;In the introduction, the authors state the following: “In contrast to models that store knowledge in their parameters, this approach explicitly exposes the role of world knowledge by asking the model to decide what knowledge to retrieve and use during inference.” In what way is is this type of knowledge-augmented model valuable compared to standard models which rely on the “latent knowledge” in their parameters? Will the future of NLP involve explicitly incorporating external knowledge, or will such methods become obsolete with bigger and better models?&lt;/li&gt;
  &lt;li&gt;Should Wikipedia be the go-to general “knowledge base”? Should we focus more on structured knowledge (such as WikiData, which is built from Wikipedia) or large text corpora?&lt;/li&gt;
  &lt;li&gt;The REALM objective involves marginalizing over the document corpus. The authors approximate this by summing over the predictions corresponding to the top-k highest scoring documents. Presumably, they take this approach (rather than coming up with a stochastic sampling method) to get the computational advantages of asynchronous MIPS. Is this biased estimator of the objective problematic or not a big deal? Why?&lt;/li&gt;
  &lt;li&gt;Is there a future for instance-based models like REALM in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transformers&lt;/code&gt;?&lt;/li&gt;
  &lt;li&gt;In the discussion, the authors mention that there are several different lenses through which you can view their method: a different take on knowledge representation and augmentation; a transformer with much larger, sparsely-attended contexts; a memory-based or retrieve-and-edit model with learned retrieval. Do any of these perspectives particularly resonate? Are there others that you prefer?&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;summary-of-hf-internal-discussion&quot;&gt;Summary of HF Internal Discussion&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;When knowledge needs to be updated, models like T5 which encode knowledge in their weights must be retrained to reflect the new information. If the model relies on the knowledge base, theoretically all you have to do is update the knowledge base. That’s a major advantage for real-life deployed QA systems, for example.&lt;/li&gt;
  &lt;li&gt;Bootstrapping the retrieval model is a tough thing to do and the Inverse Cloze Task is a smart way to go about it.&lt;/li&gt;
  &lt;li&gt;Impossible to know whether the biased objective (Q3 above) has a negative impact on results without more analysis or experimentation, but it would have been nice if the authors discussed it more in the paper.&lt;/li&gt;
  &lt;li&gt;It would nice to see evaluation on tasks other than just OpenQA.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Summary for the Hugging Face awesome-papers reading group, March 3, 2020. Paper: https://arxiv.org/abs/2002.08909.</summary></entry></feed>